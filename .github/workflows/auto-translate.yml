name: Auto-Translate QMD Files

on:
  pull_request:
    types: [opened, synchronize]
    paths:
      - '**.qmd'
      - '**.Qmd'
  push:
    branches: [main, master]
    paths:
      - '**.qmd'
      - '**.Qmd'
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to translate (leave empty for current branch)'
        required: false
        type: number
  issue_comment:
    types: [created]

permissions:
  contents: write
  pull-requests: write

jobs:
  auto-translate:
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == github.repository) ||
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'issue_comment' ||
      github.event_name == 'push'
    
    steps:
      - name: Check if triggered by valid comment command
        id: check-comment
        if: github.event_name == 'issue_comment'
        run: |
          comment="${{ github.event.comment.body }}"
          if [[ "$comment" =~ ^/translate ]]; then
            echo "valid_command=true" >> $GITHUB_OUTPUT
            if [[ ! "${{ github.event.issue.pull_request }}" ]]; then
              echo "valid_command=false" >> $GITHUB_OUTPUT
              echo "Comment was not on a PR, skipping"
            fi
          else
            echo "valid_command=false" >> $GITHUB_OUTPUT
            echo "Comment does not contain /translate command, skipping"
          fi
      
      - name: Exit if invalid comment trigger
        if: github.event_name == 'issue_comment' && steps.check-comment.outputs.valid_command != 'true'
        run: |
          echo "Workflow triggered by comment but command is invalid or not on a PR. Exiting."
          exit 0
      
      - name: Get PR information
        id: pr-info
        uses: actions/github-script@v7
        with:
          script: |
            let prNumber, prRef, prRepo, isPush = false;
            
            if (context.eventName === 'pull_request') {
              prNumber = context.payload.pull_request.number;
              prRef = context.payload.pull_request.head.ref;
              prRepo = context.payload.pull_request.head.repo.full_name;
            } else if (context.eventName === 'issue_comment') {
              const issue = context.payload.issue;
              prNumber = issue.number;
              
              // Get PR details
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              prRef = pr.head.ref;
              prRepo = pr.head.repo.full_name;
            } else if (context.eventName === 'push') {
              // For push events, create a new branch for translation
              isPush = true;
              const baseBranch = context.ref.replace('refs/heads/', '');
              // Generate timestamp: remove milliseconds and 'Z' suffix, replace : and . with -
              const timestamp = new Date().toISOString().split('.')[0].replace(/[:.]/g, '-');
              prRef = `auto-translate-${baseBranch}-${timestamp}`;
              prRepo = context.repo.owner + '/' + context.repo.repo;
              
              console.log(`Push event detected on ${baseBranch}`);
              console.log(`Will create new branch: ${prRef}`);
            } else if (context.eventName === 'workflow_dispatch') {
              const inputPrNumber = context.payload.inputs.pr_number;
              prNumber = inputPrNumber ? parseInt(inputPrNumber, 10) : null;
              if (prNumber) {
                const { data: pr } = await github.rest.pulls.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber
                });
                prRef = pr.head.ref;
                prRepo = pr.head.repo.full_name;
              } else {
                prRef = context.ref.replace('refs/heads/', '');
                prRepo = context.repo.owner + '/' + context.repo.repo;
              }
            }
            
            core.setOutput('pr_number', prNumber || '');
            core.setOutput('pr_ref', prRef || context.ref.replace('refs/heads/', ''));
            core.setOutput('pr_repo', prRepo || '');
            core.setOutput('is_push', isPush ? 'true' : 'false');
            core.setOutput('base_branch', context.ref.replace('refs/heads/', ''));
            
            console.log(`PR Number: ${prNumber}`);
            console.log(`PR Ref: ${prRef}`);
            console.log(`PR Repo: ${prRepo}`);
            console.log(`Is Push: ${isPush}`);
      
      - name: Check if PR is from a fork
        id: fork-check
        if: github.event_name != 'push'
        run: |
          pr_repo="${{ steps.pr-info.outputs.pr_repo }}"
          current_repo="${{ github.repository }}"
          
          if [ -n "$pr_repo" ] && [ "$pr_repo" != "$current_repo" ]; then
            echo "is_fork=true" >> $GITHUB_OUTPUT
            echo "âš ï¸ PR is from a fork ($pr_repo). Skipping for security reasons."
          else
            echo "is_fork=false" >> $GITHUB_OUTPUT
            echo "âœ“ PR is from the same repository"
          fi
      
      - name: Exit if PR is from a fork
        if: github.event_name != 'push' && steps.fork-check.outputs.is_fork == 'true'
        run: |
          echo "Translation workflow does not run on PRs from forks for security reasons."
          echo "The workflow requires write access to the repository."
          exit 0
      
      - name: Checkout PR branch
        if: github.event_name != 'push'
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.pr-info.outputs.pr_ref }}
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Checkout and create new branch for push events
        if: github.event_name == 'push'
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.pr-info.outputs.base_branch }}
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Create new translation branch
        if: github.event_name == 'push'
        run: |
          git checkout -b ${{ steps.pr-info.outputs.pr_ref }}
          echo "Created new branch: ${{ steps.pr-info.outputs.pr_ref }}"
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: |
          pip install openai
      
      - name: Set up GitHub Copilot CLI (if available)
        uses: austenstone/copilot-cli@v2
        continue-on-error: true
        with:
          copilot-token: ${{ secrets.COPILOT_TOKEN }}
      
      - name: Get changed QMD files
        id: changed-files
        uses: tj-actions/changed-files@v46.0.5
        with:
          files: |
            **.qmd
            **.Qmd
      
      - name: Load translation blacklist
        id: blacklist
        run: |
          if [ -f .github/translation-blacklist.txt ]; then
            echo "Blacklist file found"
            cat .github/translation-blacklist.txt
          else
            echo "No blacklist file found"
          fi
      
      - name: Process translations
        if: steps.changed-files.outputs.any_changed == 'true'
        env:
          # GitHub Copilot token (primary method)
          COPILOT_TOKEN: ${{ secrets.COPILOT_TOKEN }}
          # Support multiple AI providers via configurable environment variables (fallback)
          # Priority: AI_Model_* variables, fallback to OPENAI_API_KEY for backward compatibility
          AI_Model_API_KEY: ${{ secrets.AI_Model_API_KEY || secrets.OPENAI_API_KEY }}
          AI_Model_BASE_URL: ${{ secrets.AI_Model_BASE_URL }}
          AI_Model_Name: ${{ secrets.AI_Model_Name }}
          CHANGED_FILES: ${{ steps.changed-files.outputs.all_changed_files }}
        run: |
          # Function to check if file is in blacklist using glob patterns
          is_blacklisted() {
            local file="$1"
            if [ -f .github/translation-blacklist.txt ]; then
              while IFS= read -r pattern || [ -n "$pattern" ]; do
                # Skip comments and empty lines
                [[ "$pattern" =~ ^#.*$ ]] && continue
                [[ -z "$pattern" ]] && continue
                [[ "$pattern" =~ ^[[:space:]]*$ ]] && continue
                
                # Use case statement for glob pattern matching
                case "$file" in
                  $pattern)
                    return 0
                    ;;
                esac
              done < .github/translation-blacklist.txt
            fi
            return 1
          }
          
          # Arrays to store files
          files_to_translate=()
          files_with_pairs=()
          
          # Process each changed file
          for file in ${CHANGED_FILES}; do
            echo "Processing: $file"
            
            # Check blacklist
            if is_blacklisted "$file"; then
              echo "  âŠ— Skipped (blacklisted): $file"
              continue
            fi
            
            # Determine the translation pair
            if [[ "$file" == *.zh.qmd ]]; then
              # Chinese file - English pair
              pair="${file%.zh.qmd}.qmd"
            else
              # English file - Chinese pair
              pair="${file%.qmd}.zh.qmd"
            fi
            
            echo "  Translation pair: $pair"
            
            # Check if pair exists in the PR changes
            if echo "$CHANGED_FILES" | grep -qw "$pair"; then
              echo "  âœ“ Both language versions present in PR"
              files_with_pairs+=("$file|$pair")
            else
              # Check if pair exists in repo
              if [ -f "$pair" ]; then
                echo "  âš  Translation pair exists but not in PR, skipping auto-translation"
              else
                echo "  â†’ Will auto-translate to: $pair"
                files_to_translate+=("$file")
              fi
            fi
          done
          
          # Perform translations
          if [ ${#files_to_translate[@]} -gt 0 ]; then
            echo ""
            echo "========================================="
            echo "Auto-translating ${#files_to_translate[@]} file(s)"
            echo "========================================="
            
            # Check translation provider availability
            HAS_COPILOT=false
            HAS_EXTERNAL_AI=false
            
            if [ -n "$COPILOT_TOKEN" ]; then
              echo "âœ“ GitHub Copilot token detected"
              HAS_COPILOT=true
            fi
            
            if [ -n "$AI_Model_API_KEY" ]; then
              echo "âœ“ External AI provider configured"
              HAS_EXTERNAL_AI=true
            fi
            
            if [ "$HAS_COPILOT" = false ] && [ "$HAS_EXTERNAL_AI" = false ]; then
              echo "âœ— No translation provider configured"
              echo "   Need either COPILOT_TOKEN or AI_Model_API_KEY/OPENAI_API_KEY"
              exit 1
            fi
            
            # Store files that need translation in a file for potential Copilot batch processing
            printf "%s\n" "${files_to_translate[@]}" > /tmp/files_to_translate.txt
            
            for file in "${files_to_translate[@]}"; do
              echo ""
              echo "Translating: $file"
              
              TRANSLATION_SUCCESS=false
              
              # Use external AI models (more reliable for automated translation)
              # GitHub Copilot CLI is better for interactive use
              if [ "$HAS_EXTERNAL_AI" = true ]; then
                echo "  Using external AI provider for translation..."
                if python .github/scripts/translate_qmd.py "$file"; then
                  echo "  âœ“ Translation successful"
                  TRANSLATION_SUCCESS=true
                fi
              fi
              
              # If external AI failed or not available, could try other methods here
              if [ "$TRANSLATION_SUCCESS" = false ]; then
                echo "  âœ— Translation failed for $file"
                
                # Note: GitHub Copilot CLI (austenstone/copilot-cli) is designed for
                # interactive Q&A and reviews, not for generating complete file translations.
                # For automated translation, external AI APIs (OpenAI, MiMo, etc.) are more suitable.
                if [ "$HAS_COPILOT" = true ] && [ "$HAS_EXTERNAL_AI" = false ]; then
                  echo "  â„¹ Copilot token available but better suited for review than translation"
                  echo "    Consider configuring an external AI provider for automated translation"
                fi
              fi
            done
          else
            echo ""
            echo "No files need automatic translation"
          fi
          
          # Validate file pairs (both languages in PR)
          if [ ${#files_with_pairs[@]} -gt 0 ]; then
            echo ""
            echo "========================================="
            echo "Validating ${#files_with_pairs[@]} bilingual pair(s)"
            echo "========================================="
            
            for pair_entry in "${files_with_pairs[@]}"; do
              IFS='|' read -r file1 file2 <<< "$pair_entry"
              echo ""
              echo "Checking pair: $file1 <-> $file2"
              
              # Run spell check on both files
              echo "  Spell-checking $file1..."
              python .github/scripts/translate_qmd.py "$file1" --check-spelling || true
              
              echo "  Spell-checking $file2..."
              python .github/scripts/translate_qmd.py "$file2" --check-spelling || true
            done
          fi
      
      - name: Check for changes
        id: git-check
        run: |
          git diff --exit-code || echo "changes=true" >> $GITHUB_OUTPUT
      
      - name: Commit translations
        if: steps.git-check.outputs.changes == 'true'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add -A
          git commit -m "chore: auto-translate QMD files
          
          Automatically generated translations for modified QMD files.
          
          Co-authored-by: github-actions[bot] <github-actions[bot]@users.noreply.github.com>"
      
      - name: Push changes
        if: steps.git-check.outputs.changes == 'true'
        run: |
          git push origin ${{ steps.pr-info.outputs.pr_ref }}
      
      - name: Create Pull Request for push events
        if: github.event_name == 'push' && steps.git-check.outputs.changes == 'true'
        id: create-pr
        uses: actions/github-script@v7
        env:
          CHANGED_FILES: ${{ steps.changed-files.outputs.all_changed_files }}
        with:
          script: |
            const baseBranch = '${{ steps.pr-info.outputs.base_branch }}';
            const headBranch = '${{ steps.pr-info.outputs.pr_ref }}';
            const changedFiles = process.env.CHANGED_FILES;
            
            const { data: pr } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ðŸ¤– Auto-translate QMD files from ${baseBranch}`,
              head: headBranch,
              base: baseBranch,
              body: `## ðŸ¤– Automatic Translation
            
            This PR was automatically created by the auto-translate workflow after detecting changes to QMD files in the \`${baseBranch}\` branch.
            
            **Changed files**
            \`\`\`
            ${changedFiles}
            \`\`\`
            
            ### What was done
            - Detected new or modified .qmd files
            - Generated translations for files without translation pairs
            - Created this PR for review
            
            **Please review the translations for accuracy**, especially:
            - Technical terminology
            - Biomedical terms  
            - Code examples and their descriptions
            
            You can make manual corrections by editing the translated files directly in this PR.
            
            ---
            *This PR was created automatically by the [Auto-Translate workflow](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}).*`
            });
            
            core.setOutput('pr_number', pr.number);
            core.setOutput('pr_url', pr.html_url);
            
            console.log(`Created PR #${pr.number}: ${pr.html_url}`);
      
      - name: Review translations with GitHub Copilot (if available)
        if: steps.git-check.outputs.changes == 'true'
        uses: austenstone/copilot-cli@v2
        continue-on-error: true
        with:
          copilot-token: ${{ secrets.COPILOT_TOKEN }}
          prompt: |
            Review the translated QMD files in this pull request for:
            1. Translation accuracy and natural language flow
            2. Consistency of biomedical and bioinformatics terminology
            3. Preservation of technical terms and proper nouns
            4. Markdown formatting integrity
            5. Any potential mistranslations or awkward phrasing
            
            Focus on the newly added .qmd and .zh.qmd files.
      
      - name: React to comment (if triggered by comment)
        if: github.event_name == 'issue_comment' && steps.git-check.outputs.changes == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: context.payload.comment.id,
              content: 'rocket'
            });
      
      - name: Comment on PR
        if: github.event_name != 'push' && steps.git-check.outputs.changes == 'true'
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ steps.pr-info.outputs.pr_number }}
        with:
          script: |
            const fs = require('fs');
            let prNumber = process.env.PR_NUMBER;
            
            // Fallback to get PR number based on event type if not set
            if (!prNumber) {
              if (context.eventName === 'pull_request') {
                prNumber = context.payload.pull_request.number;
              } else if (context.eventName === 'issue_comment') {
                prNumber = context.payload.issue.number;
              } else {
                prNumber = context.issue.number;
              }
            }
            
            const triggerMethod = context.eventName === 'issue_comment' ? 'manual command `/translate`' :
                                  context.eventName === 'workflow_dispatch' ? 'manual workflow dispatch' :
                                  'automatic trigger';
            
            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: 'ðŸ¤– **Auto-Translation Complete**\n\n' +
                    `Triggered by: ${triggerMethod}\n\n` +
                    'I have automatically translated the QMD files in this PR using external AI models.\n\n' +
                    (process.env.COPILOT_TOKEN ? 'âœ¨ **GitHub Copilot Review**: A Copilot review has been performed on the translations.\n\n' : '') +
                    '**Please review the translations for accuracy**, especially:\n' +
                    '- Technical terminology\n' +
                    '- Biomedical terms\n' +
                    '- Code examples and their descriptions\n\n' +
                    'You can make manual corrections by editing the translated files directly.'
            });
      
      - name: Comment on created PR (for push events)
        if: github.event_name == 'push' && steps.git-check.outputs.changes == 'true' && steps.create-pr.outputs.pr_number
        uses: actions/github-script@v7
        env:
          NEW_PR_NUMBER: ${{ steps.create-pr.outputs.pr_number }}
        with:
          script: |
            const prNumber = process.env.NEW_PR_NUMBER;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: 'ðŸ¤– **Auto-Translation Complete**\n\n' +
                    'Triggered by: push to main/master branch\n\n' +
                    'I have automatically translated the QMD files and created this PR using external AI models.\n\n' +
                    (process.env.COPILOT_TOKEN ? 'âœ¨ **GitHub Copilot Review**: A Copilot review has been performed on the translations.\n\n' : '') +
                    '**Please review the translations for accuracy**, especially:\n' +
                    '- Technical terminology\n' +
                    '- Biomedical terms\n' +
                    '- Code examples and their descriptions\n\n' +
                    'You can make manual corrections by editing the translated files directly in this PR.'
            });
